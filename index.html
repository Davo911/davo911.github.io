<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Reverse Entropy Particle Text (3D, Chaos Mode)</title>
  <style>
    html,body{height:100%;margin:0;background:#030305;}
    #container{width:100%;height:100%;overflow:hidden;}
    canvas{display:block}
    /* tiny dev UI for debug when opened in console */
    .debug-note{position:fixed;left:8px;bottom:8px;color:#999;font-family:monospace;font-size:12px}
    .panel{position:fixed;top:10px;left:10px;background:rgba(10,10,14,0.7);-webkit-backdrop-filter:blur(4px);backdrop-filter:blur(4px);border:1px solid rgba(255,255,255,0.08);border-radius:8px;padding:8px 10px;color:#ddd;font:12px/1.3 system-ui, -apple-system, Segoe UI, Roboto;z-index:10}
    .panel h3{margin:0 0 6px 0;font-size:12px;color:#aaa;font-weight:600}
    .panel .row{display:flex;flex-wrap:wrap;gap:8px 12px;align-items:center}
    .panel label{white-space:nowrap;display:flex;gap:6px;align-items:center;cursor:pointer}
    .panel input{accent-color:#6cf}
  </style>
</head>
<body>
  <div id="container"></div>
  <div class="panel" id="effectsPanel">
    <h3>Quantum Effects</h3>
    <div class="row">
      <label><input type="checkbox" id="chkDoubleSlit">Double Slit</label>
      <label><input type="checkbox" id="chkSuperposition">Superposition</label>
      <label><input type="checkbox" id="chkEntangle">Entangle</label>
      <label><input type="checkbox" id="chkPilotWave">Pilot Wave</label>
      <label><input type="checkbox" id="chkTunneling">Tunneling</label>
      <label><input type="checkbox" id="chkZeno">Zeno</label>
    </div>
  </div>

  <script type="module">
  // TODO: replace with quantum-compliant physics engine
  // dev note: 2AM brain says this looks fine, future me will hate this
  // warning: touching this may cause the particles to unionize
  // this is the part where I pretend I understand math

  // Use absolute module URL for Three so sandboxed environments resolve it reliably
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.module.js';

  // Basic scene
  const container = document.getElementById('container');
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x030305);

  const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 5000);
  camera.position.set(0, 0, Math.max(700, window.innerWidth * 0.6));

  const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
  //Cap device pixel ratio to avoid 4K phones melting GPUs
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));  renderer.setSize(window.innerWidth, window.innerHeight);
  container.appendChild(renderer.domElement);

  // lighting
  scene.add(new THREE.AmbientLight(0x404050, 0.9));
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(0.6, 1, 0.6);
  scene.add(dir);

  // config
  // Lower particle count on small screens
  const PARTICLE_COUNT = window.innerWidth < 768 ? 3500 : 7000;
  const PARTICLE_BASE_SIZE = Math.max(1.0, (window.innerWidth / 1600));

  const TEXT_OPTIONS = ['David', '911'];

  // Near-field pointer force: snappy pull (default) and push (when mouse held)
  const POINTER_FORCE = {
    radius: Math.max(110, Math.min(window.innerWidth, window.innerHeight) * 0.08),
    pullStrength: 14,
    pushStrength: 18,
    softening: 16,
    maxDeltaVPerFrame: 2.2 // limit per-frame impulse (velocity units per 60fps frame)
  };
  const POINTER_RADIUS2 = POINTER_FORCE.radius * POINTER_FORCE.radius;

  // Effect toggles (UI-bound)
  const EFFECTS = {
    doubleSlit: false,
    superposition: true,
    entangle: false,
    pilotWave: false,
    tunneling: false,
    zeno: false,
  };

  // Superposition state
  let lambda = null;        // blend coeff per particle in [0,1]
  let lambdaTarget = null;  // desired blend coeff per particle
  let superpositionCollapsed = false;
  let superpositionResumeAt = 0;
  const SUPERPOSITION_HOLD_MS = 900;

  function seeded01(index){
    const s = Math.sin(index * 12.9898) * 43758.5453123;
    return s - Math.floor(s);
  }
  function lambdaOsc(index, t){
    const w = 0.6 + seeded01(index) * 1.4; // per-particle angular speed factor
    return 0.5 + 0.45 * Math.sin(t * w + index * 0.15);
  }
  function ensureLambdaArrays(){
    if(!lambda || lambda.length !== PARTICLE_COUNT){
      lambda = new Float32Array(PARTICLE_COUNT);
      lambdaTarget = new Float32Array(PARTICLE_COUNT);
      for(let i=0;i<PARTICLE_COUNT;i++){
        const v = seeded01(i);
        lambda[i] = v;
        lambdaTarget[i] = v;
      }
    }
  }
  function measurementCollapse(worldPointer){
    ensureLambdaArrays();
    superpositionCollapsed = true;
    const sigma = Math.max(90, Math.min(window.innerWidth, window.innerHeight) * 0.06);
    const invSigma2 = 1 / (sigma * sigma);
    for(let i=0;i<PARTICLE_COUNT;i++){
      const idx = i*3;
      const dx = worldPointer.x - positions[idx+0];
      const dy = worldPointer.y - positions[idx+1];
      const dz = worldPointer.z - positions[idx+2];
      const d2 = dx*dx + dy*dy + dz*dz;
      const pNear = Math.exp(-d2 * invSigma2); // 1 near pointer, ->0 far
      // Unbiased baseline 0.5, small local bias around pointer
      const noise = (seeded01(i + 1337) - 0.5) * 0.1 + (Math.random()-0.5)*0.04;
      const pB = Math.min(1, Math.max(0, 0.5 + 0.3 * (pNear - 0.5) + noise));
      const r = seeded01(i * 2.123 + 7.77);
      lambdaTarget[i] = (r < pB) ? 1.0 : 0.0;
    }
  }
  function resumeSuperposition(){
    ensureLambdaArrays();
    superpositionCollapsed = false;
    superpositionResumeAt = performance.now() + SUPERPOSITION_HOLD_MS;
    // keep current lambda as starting point; targets will be driven by oscillation each frame
  }

  // state
  let currentTextIndex = Math.random() > 0.5 ? 0 : 1;
  let assembling = false;
  let chaos = false;
  let bigBangActive = false;

  // buffers
  let particleGeo, particles, material;
  let positions, velocities, targets; // positions & velocities are Float32Arrays, targets is array of THREE.Vector3

  // pointer
  const pointer = new THREE.Vector2(0,0);
  const raycaster = new THREE.Raycaster();

  // util
  const rand = (a,b)=>Math.random()*(b-a)+a;

  // sprite for particles
  const spriteDataUrl = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><circle cx="32" cy="32" r="16" fill="white" opacity="1"/></svg>';

  function createParticleSystem(){
    particleGeo = new THREE.BufferGeometry();
    positions = new Float32Array(PARTICLE_COUNT * 3);
    velocities = new Float32Array(PARTICLE_COUNT * 3);
    targets = new Array(PARTICLE_COUNT);

    for(let i=0;i<PARTICLE_COUNT;i++){
      positions[i*3+0] = rand(-window.innerWidth, window.innerWidth);
      positions[i*3+1] = rand(-window.innerHeight, window.innerHeight);
      positions[i*3+2] = rand(-1200, 1200);

      velocities[i*3+0] = rand(-0.3,0.3);
      velocities[i*3+1] = rand(-0.3,0.3);
      velocities[i*3+2] = rand(-0.3,0.3);

      targets[i] = new THREE.Vector3(positions[i*3+0], positions[i*3+1], positions[i*3+2]);
    }

    particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3).setUsage(THREE.DynamicDrawUsage));

    const sprite = new THREE.TextureLoader().load(spriteDataUrl);
    material = new THREE.PointsMaterial({
      size: 5 * PARTICLE_BASE_SIZE,
      map: sprite,
      transparent: true,
      alphaTest: 0.01,
      depthTest: true,
      blending: THREE.NormalBlending,
      opacity: 0.85
    });

    particles = new THREE.Points(particleGeo, material);
    particles.frustumCulled = false;
    scene.add(particles);
  }

  // --- TEXT TO TARGETS (canvas sampling) ---
  // This approach avoids FontLoader/TextGeometry module issues and is robust in sandboxes.
  function buildTargetsFromCanvas(text){
    // Draw text on offscreen canvas then sample alpha to create target points
    const canvas = document.createElement('canvas');
    const cw = Math.min(2000, Math.max(800, Math.floor(window.innerWidth * 0.9)));
    const ch = Math.floor(cw * 0.35);
    canvas.width = cw;
    canvas.height = ch;
    const ctx = canvas.getContext('2d');

    // background black
    ctx.fillStyle = 'black';
    ctx.fillRect(0,0,cw,ch);

    // choose a bold sans font (available in browsers)
    const fontSize = Math.floor(cw / (Math.max(4, text.length) * 0.9));
    ctx.font = `bold ${fontSize}px Arial, Helvetica, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'white';

    // draw text centered
    ctx.fillText(text, cw/2, ch/2 + (fontSize*0.06));

    const img = ctx.getImageData(0,0,cw,ch);
    const data = img.data;

    // sample pixels. We'll collect many candidates then pick/dedup to EXACT particle count
    const candidates = [];
    const step = 2; // controls density (lower -> denser)

    for(let y=0;y<ch;y+=step){
      for(let x=0;x<cw;x+=step){
        const i = (y*cw + x) * 4;
        const alpha = data[i+3];
        const r = data[i];
        // threshold on brightness, can use alpha or r
        if(alpha > 50 && r > 30){
          // convert to centered coords and scale to scene
          const nx = (x - cw/2);
          const ny = (ch/2 - y);
          candidates.push(new THREE.Vector3(nx, ny, rand(-20,20)));
        }
      }
    }

    if(candidates.length === 0){
      console.warn('Text sampling produced 0 candidates for text:', text);
      // fallback: simple rectangle points
      for(let i=0;i<PARTICLE_COUNT;i++) candidates.push(new THREE.Vector3(rand(-200,200), rand(-80,80), rand(-10,10)));
    }

    // Now produce exactly PARTICLE_COUNT targets by sampling (with jitter)
    const out = new Array(PARTICLE_COUNT);
    for(let i=0;i<PARTICLE_COUNT;i++){
      const pick = candidates[Math.floor(Math.random()*candidates.length)].clone();
      // scale down because canvas px -> world units
      const scale = Math.min(1.0, window.innerWidth / (cw * 0.9));
      pick.multiplyScalar(scale * 1.0);
      // slight jitter to avoid exact overlap
      pick.x += rand(-1.2,1.2);
      pick.y += rand(-1.2,1.2);
      pick.z += rand(-6,6);
      out[i] = pick;
    }

    targets = out;
    // store as A/B when superposition is enabled for both words
    if(EFFECTS.superposition){
      if(text === TEXT_OPTIONS[0]) targetsA = out.map(v=>v.clone());
      if(text === TEXT_OPTIONS[1]) targetsB = out.map(v=>v.clone());
    }

    // remove any previous faint text plane if it exists (no longer used)
    if(window._refPlane){
      if(window._refPlane.geometry) window._refPlane.geometry.dispose();
      if(window._refPlane.material) window._refPlane.material.dispose();
      scene.remove(window._refPlane);
      window._refPlane = undefined;
    }
    if(window._refTexture){
      window._refTexture.dispose();
      window._refTexture = undefined;
    }

    // begin assembling
    assembling = true;
    chaos = false;
    bigBangActive = false;
  }

  // --- Superposition targets (precompute) ---
  let targetsA = null, targetsB = null; // for superposition morph

  // trigger a softer big bang
  function triggerBigBang(){
    bigBangActive = true;
    assembling = false;
    chaos = true;

    for(let i=0;i<PARTICLE_COUNT;i++){
      const idx = i*3;
      // direction from center + random tilt
      const cx = positions[idx+0];
      const cy = positions[idx+1];
      // compute outward vector relative to center
      const ox = cx + rand(-200,200);
      const oy = cy + rand(-200,200);
      const ang = Math.atan2(oy, ox);
      const mag = rand(3, 12); // moderate blast strength (softened)
      velocities[idx+0] = Math.cos(ang) * mag + rand(-1.5,1.5);
      velocities[idx+1] = Math.sin(ang) * mag + rand(-1.5,1.5);
      velocities[idx+2] = rand(-3,3);
    }
  }

  function reassemble(changeText){
    // optionally change text
    if(changeText){
      currentTextIndex = (currentTextIndex + 1) % TEXT_OPTIONS.length;
    } else {
      if(Math.random() > 0.6) currentTextIndex = (currentTextIndex + 1) % TEXT_OPTIONS.length;
    }
    buildTargetsFromCanvas(TEXT_OPTIONS[currentTextIndex]);
  }

  // Create particle system and initial targets
  createParticleSystem();
  buildTargetsFromCanvas(TEXT_OPTIONS[currentTextIndex]);
  // If superposition, also build the alternate targets once
  if(EFFECTS.superposition){
    const other = (currentTextIndex + 1) % TEXT_OPTIONS.length;
    buildTargetsFromCanvas(TEXT_OPTIONS[other]);
    // restore to current after capturing both
    buildTargetsFromCanvas(TEXT_OPTIONS[currentTextIndex]);
  }

  // Interaction handlers
  window.addEventListener('pointermove', (e)=>{
    pointer.x = (e.clientX / window.innerWidth) * 2 - 1;
    pointer.y = - (e.clientY / window.innerHeight) * 2 + 1;
  }, { passive: true });

  let mouseDown = false;
  let firstPress = false;
  window.addEventListener('pointerdown', (e)=>{
    if(e.button !== 0) return;
    mouseDown = true;
    if(EFFECTS.superposition){ measurementCollapse(raycaster.ray.origin.clone().add(raycaster.ray.direction.clone().multiplyScalar(Math.max(300, camera.position.z * 0.6)))) }
    else { if(!firstPress){ triggerBigBang(); firstPress = true; } else { triggerBigBang(); } }
  });
  window.addEventListener('pointerup', (e)=>{
    if(e.button !== 0) return;
    mouseDown = false;
    if(EFFECTS.superposition){ resumeSuperposition(); }
    else { reassemble(true); }
  });

  // Keep Big Bang available on Space key
  window.addEventListener('keydown', (e)=>{
    if(e.code === 'Space'){
      e.preventDefault();
      triggerBigBang();
    }
  });

  // Hook up UI toggles
  const $ = (id)=>document.getElementById(id);
  const chkDoubleSlit = $('chkDoubleSlit');
  const chkSuperposition = $('chkSuperposition');
  const chkEntangle = $('chkEntangle');
  const chkPilotWave = $('chkPilotWave');
  const chkTunneling = $('chkTunneling');
  const chkZeno = $('chkZeno');

  const applyEffectsFromUI = ()=>{
    EFFECTS.doubleSlit = !!chkDoubleSlit?.checked;
    EFFECTS.superposition = !!chkSuperposition?.checked;
    EFFECTS.entangle = !!chkEntangle?.checked;
    EFFECTS.pilotWave = !!chkPilotWave?.checked;
    EFFECTS.tunneling = !!chkTunneling?.checked;
    EFFECTS.zeno = !!chkZeno?.checked;
    // build auxiliary targets if superposition toggled on
    if(EFFECTS.superposition){
      const cur = currentTextIndex;
      const other = (cur + 1) % TEXT_OPTIONS.length;
      buildTargetsFromCanvas(TEXT_OPTIONS[other]);
      buildTargetsFromCanvas(TEXT_OPTIONS[cur]);
    }
  };

  [chkDoubleSlit,chkSuperposition,chkEntangle,chkPilotWave,chkTunneling,chkZeno].forEach(el=>{
    if(!el) return;
    el.addEventListener('change', applyEffectsFromUI);
  });

  // Defaults: Superposition on by default
  applyEffectsFromUI();
  if(chkSuperposition){ chkSuperposition.checked = true; applyEffectsFromUI(); }

  window.addEventListener('resize', ()=>{
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    // rebuild targets at new resolution for crisp text
    buildTargetsFromCanvas(TEXT_OPTIONS[currentTextIndex]);
    if(EFFECTS.superposition){
      const other = (currentTextIndex + 1) % TEXT_OPTIONS.length;
      buildTargetsFromCanvas(TEXT_OPTIONS[other]);
      buildTargetsFromCanvas(TEXT_OPTIONS[currentTextIndex]);
    }
  });

  // animation loop — velocity integrator + steering to target
  const clock = new THREE.Clock();
  let rotX = 0;
  function animate(){
    requestAnimationFrame(animate);
    const dt = Math.min(0.05, clock.getDelta());

    // world pointer for local pointer force
    raycaster.setFromCamera(pointer, camera);
    const worldPointer = raycaster.ray.origin.clone().add(raycaster.ray.direction.clone().multiplyScalar(Math.max(300, camera.position.z * 0.6)));

    for(let i=0;i<PARTICLE_COUNT;i++){
      const idx = i*3;
      let px = positions[idx+0];
      let py = positions[idx+1];
      let pz = positions[idx+2];

      let vx = velocities[idx+0];
      let vy = velocities[idx+1];
      let vz = velocities[idx+2];

      // Near-field pointer impulse (acts only very close). Pull by default, push when mouseDown.
      {
        const dxp = worldPointer.x - px;
        const dyp = worldPointer.y - py;
        const dzp = worldPointer.z - pz;
        const d2p = dxp*dxp + dyp*dyp + dzp*dzp;
        if(d2p < POINTER_RADIUS2){
          const dist = Math.sqrt(d2p + POINTER_FORCE.softening*POINTER_FORCE.softening);
          // normalized direction
          let ux = dxp / dist, uy = dyp / dist, uz = dzp / dist;
          // choose strength by mode
          const strength = mouseDown ? POINTER_FORCE.pushStrength : POINTER_FORCE.pullStrength;
          // stronger when closer; quadratic falloff
          const falloff = 1 - (d2p / POINTER_RADIUS2);
          let ax = ux * strength * falloff;
          let ay = uy * strength * falloff;
          let az = uz * strength * falloff;
          if(mouseDown){ // push flips direction
            ax = -ax; ay = -ay; az = -az;
          }
          // clamp per-frame delta-V for stability
          const dt60 = dt * 60;
          let dvx = ax * dt60, dvy = ay * dt60, dvz = az * dt60;
          const dvMag = Math.hypot(dvx, dvy, dvz);
          if(dvMag > POINTER_FORCE.maxDeltaVPerFrame){
            const s = POINTER_FORCE.maxDeltaVPerFrame / dvMag;
            dvx *= s; dvy *= s; dvz *= s;
          }
          vx += dvx; vy += dvy; vz += dvz;
        }
      }

      if(EFFECTS.doubleSlit){
        // Simple double-slit interference tug near the cursor
        // Two virtual slits offset horizontally around the pointer
        const slitSep = Math.max(40, Math.min(window.innerWidth, window.innerHeight) * 0.06);
        const slit1 = {x: worldPointer.x - slitSep*0.5, y: worldPointer.y, z: worldPointer.z};
        const slit2 = {x: worldPointer.x + slitSep*0.5, y: worldPointer.y, z: worldPointer.z};
        const k = 0.06; // wave number scale for fringe density
        const s1x = slit1.x - px, s1y = slit1.y - py, s1z = slit1.z - pz;
        const s2x = slit2.x - px, s2y = slit2.y - py, s2z = slit2.z - pz;
        const d1 = Math.hypot(s1x, s1y, s1z) + 1e-6;
        const d2 = Math.hypot(s2x, s2y, s2z) + 1e-6;
        const A1 = Math.exp(-d1*0.01), A2 = Math.exp(-d2*0.01);
        const phase = Math.cos(k*(d1 - d2));
        const I = (A1 + A2 + 2*Math.sqrt(A1*A2)*phase);
        const gradx = ((s1x/d1) * A1 + (s2x/d2) * A2) * 0.004 * I;
        const grady = ((s1y/d1) * A1 + (s2y/d2) * A2) * 0.004 * I;
        const gradz = ((s1z/d1) * A1 + (s2z/d2) * A2) * 0.003 * I;
        vx += gradx; vy += grady; vz += gradz;
      }

      if(EFFECTS.superposition && targetsA && targetsB){
        ensureLambdaArrays();
        let l = lambda[i];
        const tnow = performance.now()*0.0015;
        if(superpositionCollapsed){
          // ease lambda toward its target
          const lt = lambdaTarget[i];
          l += (lt - l) * 0.08; // approach
        } else {
          // hold the collapsed state briefly, then oscillate
          if(performance.now() < superpositionResumeAt){
            // keep current l
          } else {
            l = lambdaOsc(i, tnow) * 1.0; // already 0..1
          }
        }
        lambda[i] = l;
        const tA = targetsA[i];
        const tB = targetsB[i] || tA;
        const tx = tA.x + (tB.x - tA.x) * l;
        const ty = tA.y + (tB.y - tA.y) * l;
        const tz = tA.z + (tB.z - tA.z) * l;
        const sdx = tx - px, sdy = ty - py, sdz = tz - pz;
        const sDist = Math.sqrt(sdx*sdx + sdy*sdy + sdz*sdz) + 1e-6;
        const sSteer = Math.min(0.010, 0.0012 * sDist);
        vx += sdx * sSteer; vy += sdy * sSteer; vz += sdz * sSteer;
      }

      if(chaos || bigBangActive){
        // maintain some chaotic motion but damped so it stays readable
        vx += rand(-0.6,0.6);
        vy += rand(-0.6,0.6);
        vz += rand(-0.3,0.3);
        vx *= 0.987;
        vy *= 0.987;
        vz *= 0.995;

        px += vx * dt * 60;
        py += vy * dt * 60;
        pz += vz * dt * 60;

      } else if(assembling && targets && targets[i]){
        // steer towards target gently
        const t = targets[i];
        const dx = t.x - px;
        const dy = t.y - py;
        const dz = t.z - pz;
        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) + 1e-6;

        // steering strength: slow for smooth assembly
        const steer = Math.min(0.007, 0.0009 * dist);
        vx += dx * steer;
        vy += dy * steer;
        vz += dz * steer;

        // damping to settle
        vx *= 0.90;
        vy *= 0.90;
        vz *= 0.92;

        // tiny breathing offset applied on top
        const breathe = Math.sin((performance.now()*0.002) + i) * 0.22;

        px += vx * dt * 60 + breathe * 0.25;
        py += vy * dt * 60 + Math.cos((performance.now()*0.0016) + i) * 0.18;
        pz += vz * dt * 60;

      } else {
        // idle float
        vx += Math.sin(performance.now()*0.0007 + i) * 0.002;
        vy += Math.cos(performance.now()*0.0009 + i) * 0.002;
        vz += Math.sin(performance.now()*0.0005 + i) * 0.001;

        px += vx * dt * 60;
        py += vy * dt * 60;
        pz += vz * dt * 60;

        vx *= 0.995; vy *= 0.995; vz *= 0.995;
      }

      // keep particles in soft bounds so they reappear nicely
      const bound = Math.max(window.innerWidth, window.innerHeight) * 2;
      if(Math.abs(px) > bound || Math.abs(py) > bound || pz > 4000 || pz < -4000){
        px = THREE.MathUtils.lerp(px, rand(-200,200), 0.04);
        py = THREE.MathUtils.lerp(py, rand(-200,200), 0.04);
        pz = THREE.MathUtils.lerp(pz, rand(-600,600), 0.04);
      }

      positions[idx+0] = px;
      positions[idx+1] = py;
      positions[idx+2] = pz;

      velocities[idx+0] = vx;
      velocities[idx+1] = vy;
      velocities[idx+2] = vz;
    }

    // notify attribute update
    particleGeo.attributes.position.needsUpdate = true;

    // rotate the whole cloud gently around X axis — speed up a bit when assembled
    rotX += (assembling ? 0.0022 : 0.0009);
    if(particles) particles.rotation.x = rotX;
    if(window._refPlane) window._refPlane.rotation.x = rotX + 0.25;

    renderer.render(scene, camera);
  }

  animate();

  // Convenience API for console tuning
  window.REVERSE_PARTICLE_DEBUG = {
    triggerBigBang: triggerBigBang,
    reassemble: (change)=>reassemble(!!change),
    setText: (s)=>{ if(typeof s === 'string'){ TEXT_OPTIONS[0]=s; buildTargetsFromCanvas(s);} },
    getState: ()=>({assembling,chaos,bigBangActive,currentText: TEXT_OPTIONS[currentTextIndex]})
  };

  </script>
</body>
</html>
